#!/usr/bin/python3

import os
import sys
import pyexiv2
import logging
import logging.handlers
import optparse
import functools

parser = optparse.OptionParser(usage="usage: %prog [options] arg1 ... argn", version="%prog 0.9")
parser.add_option("-v", "--verbose", dest="verbose", action="store_true",
                  help="enables verbose messages")
parser.add_option("-d", "--depth", dest="depth",
                  action="store", type="int", default=1, metavar="INT",
                  help="sets the maximum directory recursion level")
(options, args) = parser.parse_args()

msg = logging.getLogger('Logger')
msgch = logging.StreamHandler()
level = logging.INFO
if options.verbose:
    level = logging.DEBUG
msg.setLevel(level)
msgch.setLevel(level)
msgch.setFormatter(logging.Formatter("%(message)s"))
msg.addHandler(msgch)

supported_formats = ['jpg', 'jpeg', 'nef', 'cr2' ]

def get_candidate(date, i, ext):
    return u"%s_%02d.%s" % (date, i, ext)

def rename_photo(file):
    # read the exif info from the file
    info = pyexiv2.ImageMetadata(file)
    info.read()

    # retrieve an exif date
    if "Exif.Photo.DateTimeOriginal" in info.exif_keys:
        exifdate = info["Exif.Photo.DateTimeOriginal"]
    elif "Exif.Image.DateTime" in info.exif_keys:
        exifdate = info["Exif.Image.DateTime"]
    else:
        msg.debug("no exif for file '%s'" % file)
        return

    # prepare all elements for renaming iterations
    folder = os.path.dirname(file)
    date = exifdate.value.strftime("%Y-%m-%d_%H%M%S")
    i = 1
    ext = file.split('.')[-1].lower()
    newname = get_candidate(date, i, ext)

    # avoid renaming if the file we're dealing with already matches the
    # desired new name
    if date == os.path.basename(file)[:len(date)]:
        msg.debug("untouched '%s'" % file)
        return

    # Create a complete path
    newfile = os.path.join(folder, newname)
    while os.path.isfile(newfile):
        # The file exists, try the next increment
        i = i + 1
        newname = get_candidate(date, i, ext)
        newfile = os.path.join(folder, newname)

    # Companion file for DT
    companion = ''.join([file, '.xmp'])
    if os.path.isfile(companion):
        newcompanion = ''.join([newfile, '.xmp'])
        os.rename(companion, newcompanion) 
        msg.info("renamed companion '%s' to '%s'" % (companion, newcompanion))

    # A free filename has been found
    os.rename(file, newfile)
    msg.info("renamed '%s' to '%s'" % (file, newfile))

def cmp_filename(a, b):
    # first we look if a or b are a substring of the other, this prevents
    # having shorter filenames being considered greater than long ones
    (ba, xa) = os.path.splitext(a)
    (bb, xb) = os.path.splitext(b)
    if ba.find(bb) == 0:
        return 1
    elif bb.find(ba) == 0:
        return -1

    # Compare w/o looking at the letter cases
    if a.upper() < b.upper():
        return -1
    elif a.upper() > b.upper():
        return 1
    # Consider letter cases from now on
    elif a < b:
        return 1
    elif a > b:
        return -1
    else:
        return 0

def visit_directory(folder, maxdepth=5, depth=1):
    try:
        for entry in sorted(os.listdir(folder), key=functools.cmp_to_key(cmp_filename)):
            absentry = os.path.join(folder, entry)
            if os.path.isdir(absentry) and os.access(absentry, os.X_OK) and depth < maxdepth:
                visit_directory(absentry, maxdepth, depth + 1)
            elif os.path.splitext(absentry)[1][1:].lower() in supported_formats:
                rename_photo(absentry)
    except e:
        msg.error("something prevented renaming elements in %s\n%s" % (folder, str(e)))

if not args:
    parser.print_help()
else:
    for arg in [r for r in args if os.path.isdir(r)]:
        visit_directory(arg, options.depth, 1)
    
