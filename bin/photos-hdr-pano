#!/usr/bin/env python
# -*- Encoding: utf-8 -*-

import optparse
import sys
import os
import subprocess
import multiprocessing
import signal

_verbosity = 1

def info(msg):
    if _verbosity >= 0:
        sys.stdout.write("error: %s" % (msg))

def info(msg):
    if _verbosity >= 1:
        sys.stdout.write("info: %s" % (msg))

def debug(msg):
    if _verbosity >= 2:
        sys.stdout.write("debug: %s" % (msg))

def option_parser():
    parser = optparse.OptionParser()
    parser.add_option('-k', '--keep', dest='keep',
                      action='store_true', help='Keep intermediary files', default=False)
    parser.add_option('-s', '--stack', dest='stack',
                      type='int', help='Bracketed stack depth', default=3)
    parser.add_option('-a', '--no-align', dest='align',
                      action='store_false', help='Do not align before HDR merging', default=True)
    parser.add_option('-v', '--verbose', dest='verbose',
                      action='store_true', help='Be verbose', default=False)
    parser.add_option('-j', '--parallel', dest='j',
                      type='int', help='Parallel number of stacks to process in parallel', default=0)
    return parser

class stack(object):
    def __init__(self, identifier, stack_size, num_stacks, shots, keep=False):
        self.id = identifier
        self.stack_size = stack_size
        self.num_stacks = num_stacks
        self.shots = shots
        self.aligned = None
        self.hdr = None
        self.cleanup = True
        self.keep = keep
        self.process = None

    def __del__(self):
        if self.cleanup and not self.keep:
            if self.aligned:
                for f in self.aligned:
                    os.unlink(f)
            if self.process and self.process.returncode:
                process.kill()

    def align(self):
        align_pfx = 'aligned_%04d_' % self.id
        cmd = [ 'align_image_stack', '-a', align_pfx, '-g', '10', '-c', '16', '-l', '-C' ]
        cmd.extend(self.shots)

        info("aligning stack %d/%d\n" % (self.id, self.num_stacks))
        debug("%s\n" % (' '.join(cmd)))
        self.process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        align_image_stack = self.process
        (stdout, stderr) = align_image_stack.communicate()
        if align_image_stack.returncode:
            error('align_image_stack returned %d value' % align_image_stack.returncode)
            error('here is the output\n%s' % '\n'.join(stdout, stderr))
            sys.exit(1)

        self.process = None
        self.aligned = ['%s%04d.tif' % (align_pfx, i)  for i in xrange(self.stack_size)]

    def prealigned(self):
        self.cleanup = False
        self.aligned = self.shots

    def merge(self):
        hdr_pattern = 'hdr_%04d.tif'
        self.hdr = hdr_pattern % self.id
        # cmd = [ 'hugin_hdrmerge', '-m', 'khan', '-i' , '6', '-s', '30', '-o', self.hdr]
        cmd = [ 'hugin_hdrmerge', '-m', 'avg_slow', '-o', self.hdr]
        cmd.extend(self.aligned)

        info("hdr merging stack %d/%d\n" % (self.id, self.num_stacks))
        debug("%s\n" % (' '.join(cmd)))
        self.process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        hugin_hdrmerge = self.process
        (stdout, stderr) = hugin_hdrmerge.communicate()
        if hugin_hdrmerge.returncode:
            error('hugin_hdrmerge returned %d value' % hugin_hdrmerge.returncode)
            error('here is the output\n%s' % '\n'.join(stdout, stderr))
            sys.exit(1)

        self.process = None

    def copy_exif(self):
        cmd = [ 'exiftool', '-overwrite_original', '-tagsFromFile', self.shots[0], '-Make', '-Model', '-FocalLength', '-FocalLengthIn35mmFormat', '-Iso', self.hdr ]
        info("copying EXIF data %d/%d\n" % (self.id, self.num_stacks))
        debug("%s\n" % (' '.join(cmd)))
        self.process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        exiftool = self.process
        (stdout, stderr) = exiftool.communicate()
        if exiftool.returncode:
            error('exiftool returned %d value' % exiftool.returncode)
            error('here is the output\n%s' % '\n'.join(stdout, stderr))
            sys.exit(1)

def process_stack(options, s):
    try:
        if options.align:
            s.align()
        else:
            s.prealigned()
        s.merge()
        # s.copy_exif()
        return s
    except KeyboardInterrupt:
        info(" worker quitting by ctrl-c\n")
        return s
    
def main():
    parser = option_parser()
    (options, args) = parser.parse_args()

    if options.verbose:
        global _verbosity
        _verbosity += 1

    files = sorted(args)
    if len(files) % options.stack:
        error("error: file list length is not a multiple of the stack depth")
        sys.exit(1)

    numstack = len(files)/options.stack
    stacks = []
    processes = None
    if options.j > 0:
        processes = options.j
    if processes > numstack:
        processes = numstack

    pool = multiprocessing.Pool(processes)
    try:
        for n in xrange(numstack):
            s = stack(n+1, options.stack, numstack, files[options.stack*n:options.stack*(n+1)], options.keep)
            r = pool.apply_async(process_stack, (options, s))
            stacks.append(r)

        pool.close()
        pool.join()

        cmd = [ 'hugin' ]
        for r in stacks:
            if r.ready():
                s = r.get()
                cmd.append(s.hdr)
                s.cleanup = False # this is a copy marshalled by the slave
        print(' '.join(cmd))
    except KeyboardInterrupt:
        info("quitting by crtl-c ...")
        if pool is not None:
            pool.terminate()
            pool.join()

if __name__ == "__main__":
    main()
